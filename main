#!/bin/bash
#PBS -l nodes=1:ppn=16,walltime=2:00:00
#PBS -l vmem=50gb
#PBS -N PyNets

# This file is used to execute PyNets on brainlife.
# brainlife stages this git repo, writes `config.json` and execute this script.
# this script reads the `config.json` and execute pynets container through singularity

# you can run this script(main) without any parameter to test how this App will run outside brainlife
# you will need to copy config.json.brainlife-sample to config.json before running `main` as `main`
# will read all parameters from config.json

set -x
set -e
set -f

mkdir -p output tmp

# usage: pynets [-h] -id A subject id or other unique identifier
#               [A subject id or other unique identifier ...]
#               [-func Path to input functional file required for functional connectomes) [Path to input functional file (required for functional connectomes) ...]]
#               [-dwi Path to diffusion-weighted imaging data file (required for dmri connectomes) [Path to diffusion-weighted imaging data file (required for dmri connectomes) ...]]
#               [-bval Path to b-values file (required for dmri connectomes) [Path to b-values file (required for dmri connectomes) ...]]
#               [-bvec Path to b-vectors file (required for dmri connectomes) [Path to b-vectors file (required for dmri connectomes) ...]]
#               [-anat Path to a skull-stripped anatomical Nifti1Image [Path to a skull-stripped anatomical Nifti1Image ...]]
#               [-m Path to a T1w brain mask image (if available) in native anatomical space [Path to a T1w brain mask image (if available) in native anatomical space ...]]
#               [-conf Confound regressor file (.tsv/.csv format) [Confound regressor file (.tsv/.csv format) ...]]
#               [-g Path to graph file input. [Path to graph file input. ...]]
#               [-roi Path to binarized Region-of-Interest (ROI) Nifti1Image in template MNI space. [Path to binarized Region-of-Interest (ROI) Nifti1Image in template MNI space. ...]]
#               [-ref Atlas reference file path]
#               [-way Path to binarized Nifti1Image to constrain tractography [Path to binarized Nifti1Image to constrain tractography ...]]
#               [-ua Path to custom parcellation file [Path to custom parcellation file ...]]
#               [-mod Connectivity estimation/reconstruction method [Connectivity estimation/reconstruction method ...]]
#               [-a Atlas [Atlas ...]]
#               [-ns Spherical centroid node size [Spherical centroid node size ...]]
#               [-thr Graph threshold]
#               [-min_thr Multi-thresholding minimum threshold]
#               [-max_thr Multi-thresholding maximum threshold]
#               [-step_thr Multi-thresholding step size]
#               [-sm Smoothing value (mm fwhm) [Smoothing value (mm fwhm) ...]]
#               [-hp High-pass filter (Hz) [High-pass filter (Hz) ...]]
#               [-es Node extraction strategy [Node extraction strategy ...]]
#               [-k Number of k clusters [Number of k clusters ...]]
#               [-ct Clustering type [Clustering type ...]]
#               [-cm Cluster mask [Cluster mask ...]]
#               [-ml Minimum fiber length for tracking [Minimum fiber length for tracking ...]]
#               [-dg Direction getter [Direction getter ...]]
#               [-norm Normalization strategy for resulting graph(s)] [-bin]
#               [-dt] [-mst] [-p Pruning Strategy] [-df]
#               [-mplx Perform various levels of multiplex graph analysis (only if both structural and diffusion connectometry is run simultaneously.]
#               [-embed] [-spheres]
#               [-n Resting-state network [Resting-state network ...]]
#               [-vox {1mm,2mm}] [-plt] [-pm Cores,memory]
#               [-plug Scheduler type] [-v] [-clean] [-work Working directory]
#               [--version]
#               output_dir


#construct arguments for optional inputs
optional=""

dwi=$(jq -r .dwi config.json)
if [ $dwi != "null" ]; then
    bval=`pwd`/$(jq -r .bvals config.json)
    bvec=`pwd`/$(jq -r .bvecs config.json)
    optional="$optional -dwi $(pwd)/$dwi -bval $bval -bvec $bvec"
fi

bold=$(jq -r .bold config.json)
if [ $bold != "null" ];then
    conf=`pwd`/$(jq -r .regressors config.json)
    if [ $conf != "null" ];then
        optional="$optional -func $(pwd)/$bold -conf $conf"
    else
        optional="$optional -func $(pwd)/$bold"
    fi
fi

mask=$(jq -r .mask config.json)
if [ $mask != "null" ];then
    optional="$optional -m $(pwd)/$mask"
fi

useratlas=$(jq -r .useratlas config.json)
if [ $useratlas != "null" ]; then
    if [ $(echo "$useratlas" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$useratlas"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -ua $(pwd)/$piece"
        done
    else
        optional="$optional -ua $(pwd)/$useratlas"
    fi
fi

atlas=$(jq -r .atlas config.json)
if [ $atlas != "null" ]; then
    if [ $(echo "$atlas" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$atlas"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -a $piece"
        done
    else
        optional="$optional -a $atlas"
    fi
fi

min_thr=$(jq -r .min_thr config.json)
max_thr=$(jq -r .max_thr config.json)
step_thr=$(jq -r .step_thr config.json)
thr=$(jq -r .thr config.json)
if [ $min_thr != "null" ]; then
    optional="$optional -min_thr $min_thr"
    optional="$optional -max_thr $max_thr"
    optional="$optional -step_thr $step_thr"
else
    optional="$optional -thr $thr"
fi

# Boolean options
[ "$(jq -r .mst config.json)" == "true" ] && optional="$optional -mst"
[ "$(jq -r .dt config.json)" == "true" ] && optional="$optional -dt"
[ "$(jq -r .embed config.json)" == "true" ] && optional="$optional -embed"
[ "$(jq -r .df config.json)" == "true" ] && optional="$optional -df"
[ "$(jq -r .plt config.json)" == "true" ] && optional="$optional -plt"
[ "$(jq -r .bin config.json)" == "true" ] && optional="$optional -bin"
[ "$(jq -r .spheres config.json)" == "true" ] && optional="$optional -spheres"

prune=$(jq -r .p config.json)
if [ "$prune" != "1" ]; then
    optional="$optional -p $prune"
fi

norm=$(jq -r .norm config.json)
if [ "$norm" != "1" ]; then
    optional="$optional -norm $norm"
fi

mplx=$(jq -r .mplx config.json)
if [ "$mplx" != "0" ]; then
    optional="$optional -mplx $mplx"
fi

rsn=$(jq -r .n config.json)
if [ "$rsn" != "null" ]; then
    if [ $(echo "$rsn" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$rsn"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -n $piece"
        done
    else
        optional="$optional -n $rsn"
    fi
fi

em=$(jq -r .em config.json)
if [ "$em" != "mean" ]; then
    if [ $(echo "$em" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$em"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -em $piece"
        done
    else
        optional="$optional -em $em"
    fi
fi

sm=$(jq -r .sm config.json)
if [ "$sm" != "0" ]; then
    if [ $(echo "$sm" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$sm"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -sm $piece"
        done
    else
        optional="$optional -sm $sm"
    fi
fi

hp=$(jq -r .hp config.json)
if [ "$hp" != "0" ]; then
    if [ $(echo "$hp" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$hp"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -hp $piece"
        done
    else
        optional="$optional -hp $hp"
    fi
fi

dg=$(jq -r .dg config.json)
if [ "$dg" != "det" ]; then
    if [ $(echo "$dg" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$dg"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -dg $piece"
        done
    else
        optional="$optional -dg $dg"
    fi
fi

ml=$(jq -r .ml config.json)
if [ "$ml" != "20" ]; then
    if [ $(echo "$ml" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$ml"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -ml $piece"
        done
    else
        optional="$optional -ml $ml"
    fi
fi

tol=$(jq -r .tol config.json)
if [ "$tol" != "8" ]; then
    if [ $(echo "$tol" | wc -l) -gt 1 ]; then
        printf -v str_literal '%b' "$tol"
        IFS=$'\n' read -r -a pieces <<<"$str_literal"
        for piece in "${pieces[@]}"; do
            optional="$optional -tol $piece"
        done
    else
        optional="$optional -tol $tol"
    fi
fi

singularity run -e docker://dpys/pynets:03a1f40583de5a7948e31741173994674a7450a2 pynets \
    `pwd`/output \
    -id $(jq -r .id config.json) \
    -anat `pwd`/$(jq -r .t1 config.json) \
    -work `pwd`/work \
    -mod $(jq -r .mod config.json) \
    $optional

# graph
# diffusion
# diffusion / functional
# functional
